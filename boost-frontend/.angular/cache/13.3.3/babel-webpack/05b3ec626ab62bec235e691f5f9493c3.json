{"ast":null,"code":"import { Injectable, EventEmitter, Directive, ElementRef, NgZone, Input, Output, HostListener, NgModule } from '@angular/core';\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\nimport * as ɵngcc0 from '@angular/core';\nlet WindowRef = /*#__PURE__*/(() => {\n  class WindowRef {\n    /**\n     * @return {?}\n     */\n    get nativeWindow() {\n      return window;\n    }\n\n  }\n\n  WindowRef.ɵfac = function WindowRef_Factory(t) {\n    return new (t || WindowRef)();\n  };\n\n  WindowRef.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: WindowRef,\n    factory: WindowRef.ɵfac\n  });\n  return WindowRef;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/** @type {?} */\n\n\nconst MAX_LOOKUP_RETRIES = 3;\nlet AutosizeDirective = /*#__PURE__*/(() => {\n  class AutosizeDirective {\n    /**\n     * @param {?} element\n     * @param {?} _window\n     * @param {?} _zone\n     */\n    constructor(element, _window, _zone) {\n      this.element = element;\n      this._window = _window;\n      this._zone = _zone;\n      this.onlyGrow = false;\n      this.useImportant = false;\n      this.resized = new EventEmitter();\n      this.autosize = true;\n      this.retries = 0;\n      this._destroyed = false;\n\n      if (this.element.nativeElement.tagName !== 'TEXTAREA') {\n        this._findNestedTextArea();\n      } else {\n        this.textAreaEl = this.element.nativeElement;\n        this.textAreaEl.style['overflow-y'] = 'hidden';\n\n        this._onTextAreaFound();\n      }\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n\n\n    set minRows(value) {\n      this._minRows = value;\n\n      if (this.textAreaEl) {\n        this.textAreaEl.rows = value;\n      }\n    }\n\n    /**\n     * @param {?} autosize\n     * @return {?}\n     */\n    set _autosize(autosize) {\n      this.autosize = typeof autosize === 'boolean' ? autosize : true;\n    }\n\n    /**\n     * @param {?} textArea\n     * @return {?}\n     */\n    onInput(textArea) {\n      this.adjust();\n    }\n    /**\n     * @return {?}\n     */\n\n\n    ngOnDestroy() {\n      this._destroyed = true;\n\n      if (this._windowResizeHandler) {\n        this._window.nativeWindow.removeEventListener('resize', this._windowResizeHandler, false);\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n\n    ngAfterContentChecked() {\n      this.adjust();\n    }\n    /**\n     * @param {?} changes\n     * @return {?}\n     */\n\n\n    ngOnChanges(changes) {\n      this.adjust(true);\n    }\n    /**\n     * @return {?}\n     */\n\n\n    _findNestedTextArea() {\n      this.textAreaEl = this.element.nativeElement.querySelector('TEXTAREA');\n\n      if (!this.textAreaEl && this.element.nativeElement.shadowRoot) {\n        this.textAreaEl = this.element.nativeElement.shadowRoot.querySelector('TEXTAREA');\n      }\n\n      if (!this.textAreaEl) {\n        if (this.retries >= MAX_LOOKUP_RETRIES) {\n          console.warn('ngx-autosize: textarea not found');\n        } else {\n          this.retries++;\n          setTimeout(\n          /**\n          * @return {?}\n          */\n          () => {\n            this._findNestedTextArea();\n          }, 100);\n        }\n\n        return;\n      }\n\n      this.textAreaEl.style['overflow-y'] = 'hidden';\n\n      this._onTextAreaFound();\n    }\n    /**\n     * @return {?}\n     */\n\n\n    _onTextAreaFound() {\n      this._addWindowResizeHandler();\n\n      setTimeout(\n      /**\n      * @return {?}\n      */\n      () => {\n        this.adjust();\n      });\n    }\n    /**\n     * @return {?}\n     */\n\n\n    _addWindowResizeHandler() {\n      this._windowResizeHandler = Debounce(\n      /**\n      * @return {?}\n      */\n      () => {\n        this._zone.run(\n        /**\n        * @return {?}\n        */\n        () => {\n          this.adjust();\n        });\n      }, 200);\n\n      this._zone.runOutsideAngular(\n      /**\n      * @return {?}\n      */\n      () => {\n        this._window.nativeWindow.addEventListener('resize', this._windowResizeHandler, false);\n      });\n    }\n    /**\n     * @param {?=} inputsChanged\n     * @return {?}\n     */\n\n\n    adjust(inputsChanged = false) {\n      if (this.autosize && !this._destroyed && this.textAreaEl && this.textAreaEl.parentNode) {\n        /** @type {?} */\n        const currentText = this.textAreaEl.value;\n\n        if (inputsChanged === false && currentText === this._oldContent && this.textAreaEl.offsetWidth === this._oldWidth) {\n          return;\n        }\n\n        this._oldContent = currentText;\n        this._oldWidth = this.textAreaEl.offsetWidth;\n        /** @type {?} */\n\n        const clone = this.textAreaEl.cloneNode(true);\n        /** @type {?} */\n\n        const parent = this.textAreaEl.parentNode;\n        clone.style.width = this.textAreaEl.offsetWidth + 'px';\n        clone.style.visibility = 'hidden';\n        clone.style.position = 'absolute';\n        clone.textContent = currentText;\n        parent.appendChild(clone);\n        clone.style['overflow-y'] = 'hidden';\n        clone.style.height = 'auto';\n        /** @type {?} */\n\n        let height = clone.scrollHeight; // add into height top and bottom borders' width\n\n        /** @type {?} */\n\n        let computedStyle = this._window.nativeWindow.getComputedStyle(clone, null);\n\n        height += parseInt(computedStyle.getPropertyValue('border-top-width'));\n        height += parseInt(computedStyle.getPropertyValue('border-bottom-width')); // add into height top and bottom paddings width\n\n        height += parseInt(computedStyle.getPropertyValue('padding-top'));\n        height += parseInt(computedStyle.getPropertyValue('padding-bottom'));\n        /** @type {?} */\n\n        const oldHeight = this.textAreaEl.offsetHeight;\n        /** @type {?} */\n\n        const willGrow = height > oldHeight;\n\n        if (this.onlyGrow === false || willGrow) {\n          /** @type {?} */\n          const lineHeight = this._getLineHeight();\n          /** @type {?} */\n\n\n          const rowsCount = height / lineHeight;\n\n          if (this._minRows && this._minRows >= rowsCount) {\n            height = this._minRows * lineHeight;\n          } else if (this.maxRows && this.maxRows <= rowsCount) {\n            // never shrink the textarea if onlyGrow is true\n\n            /** @type {?} */\n            const maxHeight = this.maxRows * lineHeight;\n            height = this.onlyGrow ? Math.max(maxHeight, oldHeight) : maxHeight;\n            this.textAreaEl.style['overflow-y'] = 'auto';\n          } else {\n            this.textAreaEl.style['overflow-y'] = 'hidden';\n          }\n          /** @type {?} */\n\n\n          const heightStyle = height + 'px';\n          /** @type {?} */\n\n          const important = this.useImportant ? 'important' : '';\n          this.textAreaEl.style.setProperty('height', heightStyle, important);\n          this.resized.emit(height);\n        }\n\n        parent.removeChild(clone);\n      }\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n\n    _getLineHeight() {\n      /** @type {?} */\n      let lineHeight = parseInt(this.textAreaEl.style.lineHeight, 10);\n\n      if (isNaN(lineHeight) && this._window.nativeWindow.getComputedStyle) {\n        /** @type {?} */\n        const styles = this._window.nativeWindow.getComputedStyle(this.textAreaEl);\n\n        lineHeight = parseInt(styles.lineHeight, 10);\n      }\n\n      if (isNaN(lineHeight)) {\n        /** @type {?} */\n        const fontSize = this._window.nativeWindow.getComputedStyle(this.textAreaEl, null).getPropertyValue('font-size');\n\n        lineHeight = Math.floor(parseInt(fontSize.replace('px', ''), 10) * 1.5);\n      }\n\n      return lineHeight;\n    }\n\n  }\n\n  AutosizeDirective.ɵfac = function AutosizeDirective_Factory(t) {\n    return new (t || AutosizeDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(WindowRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n\n  AutosizeDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: AutosizeDirective,\n    selectors: [[\"\", \"autosize\", \"\"]],\n    hostBindings: function AutosizeDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵlistener(\"input\", function AutosizeDirective_input_HostBindingHandler($event) {\n          return ctx.onInput($event.target);\n        });\n      }\n    },\n    inputs: {\n      onlyGrow: \"onlyGrow\",\n      useImportant: \"useImportant\",\n      minRows: \"minRows\",\n      _autosize: [\"autosize\", \"_autosize\"],\n      maxRows: \"maxRows\"\n    },\n    outputs: {\n      resized: \"resized\"\n    },\n    features: [ɵngcc0.ɵɵNgOnChangesFeature]\n  });\n  /** @nocollapse */\n\n  return AutosizeDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nif (false) {\n  /**\n   * @type {?}\n   * @private\n   */\n  AutosizeDirective.prototype._minRows;\n  /** @type {?} */\n\n  AutosizeDirective.prototype.maxRows;\n  /** @type {?} */\n\n  AutosizeDirective.prototype.onlyGrow;\n  /** @type {?} */\n\n  AutosizeDirective.prototype.useImportant;\n  /** @type {?} */\n\n  AutosizeDirective.prototype.resized;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  AutosizeDirective.prototype.autosize;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  AutosizeDirective.prototype.retries;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  AutosizeDirective.prototype.textAreaEl;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  AutosizeDirective.prototype._oldContent;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  AutosizeDirective.prototype._oldWidth;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  AutosizeDirective.prototype._windowResizeHandler;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  AutosizeDirective.prototype._destroyed;\n  /** @type {?} */\n\n  AutosizeDirective.prototype.element;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  AutosizeDirective.prototype._window;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  AutosizeDirective.prototype._zone;\n  /* Skipping unhandled member: ;*/\n\n  /* Skipping unhandled member: ;*/\n}\n/**\n * @param {?} func\n * @param {?} wait\n * @param {?=} immediate\n * @return {?}\n */\n\n\nfunction Debounce(func, wait, immediate = false) {\n  /** @type {?} */\n  let timeout;\n  return (\n    /**\n    * @return {?}\n    */\n    function () {\n      /** @type {?} */\n      const context = this;\n      /** @type {?} */\n\n      const args = arguments;\n      /** @type {?} */\n\n      const later =\n      /**\n      * @return {?}\n      */\n      function () {\n        timeout = null;\n\n        if (!immediate) {\n          func.apply(context, args);\n        }\n      };\n      /** @type {?} */\n\n\n      const callNow = immediate && !timeout;\n      clearTimeout(timeout);\n      timeout = setTimeout(later, wait);\n\n      if (callNow) {\n        func.apply(context, args);\n      }\n    }\n  );\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nlet AutosizeModule = /*#__PURE__*/(() => {\n  class AutosizeModule {}\n\n  AutosizeModule.ɵfac = function AutosizeModule_Factory(t) {\n    return new (t || AutosizeModule)();\n  };\n\n  AutosizeModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: AutosizeModule\n  });\n  AutosizeModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    providers: [WindowRef],\n    imports: [[]]\n  });\n  return AutosizeModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(AutosizeModule, {\n    declarations: [AutosizeDirective],\n    exports: [AutosizeDirective]\n  });\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nexport { AutosizeDirective, AutosizeModule, WindowRef as ɵa }; //# sourceMappingURL=ngx-autosize.js.map","map":null,"metadata":{},"sourceType":"module"}