{"ast":null,"code":"import { Directive, ElementRef, ChangeDetectorRef, Inject, Input, InjectionToken, NgModule, Optional } from '@angular/core';\nimport { DOCUMENT } from '@angular/common';\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\nimport * as ɵngcc0 from '@angular/core';\nlet AutofocusFixConfig = /*#__PURE__*/(() => {\n  class AutofocusFixConfig {\n    /**\n     * @param {?} config\n     */\n    constructor(config) {\n      /**\n       * In case `true` .focus() events will be wrapped by `setTimeout(() => ...)`.\n       *\n       * Notice:\n       * I'm not sure that the action is a good practice, however this ability added because of next issues:\n       * - https://github.com/korniychuk/angular-autofocus-fix/issues/1\n       * - https://github.com/spirosikmd/angular2-focus/issues/46\n       */\n      this.async = false;\n      /**\n       * In case `true`: treat an empty string, an empty array and an empty object as a falsy value.\n       * In case `false`(default): each of these values treats as truthy.\n       */\n\n      this.smartEmptyCheck = false;\n      /**\n       * In case `true`: trigger {\\@link ChangeDetectorRef.detectChanges}() after {\\@link HTMLElement.focus}().\n       *\n       * This is helpful in the case when the HTMLElement to which {\\@link AutofocusFixDirective} added\n       * wrapped by another directive/component that has some binding related to focus of the element.\n       * In this case without enabling .triggerChangeDetection option Angular throws ExpressionChangedAfterItHasBeenCheckedError.\n       *\n       * A striking example is the <mat-form-field> from the Angular Material that wraps <input> control.\n       */\n\n      this.triggerDetectChanges = false;\n      AutofocusFixConfig.keys.filter(\n      /**\n      * @param {?} name\n      * @return {?}\n      */\n      name => config[name] !== undefined) // @ts-ignore\n      .forEach(\n      /**\n      * @param {?} name\n      * @return {?}\n      */\n      name => this[name] = config[name]);\n    }\n\n  }\n\n  AutofocusFixConfig.keys = ['async', 'smartEmptyCheck', 'triggerDetectChanges'];\n  return AutofocusFixConfig;\n})();\n\nif (false) {\n  /** @type {?} */\n  AutofocusFixConfig.keys;\n  /**\n   * In case `true` .focus() events will be wrapped by `setTimeout(() => ...)`.\n   *\n   * Notice:\n   * I'm not sure that the action is a good practice, however this ability added because of next issues:\n   * - https://github.com/korniychuk/angular-autofocus-fix/issues/1\n   * - https://github.com/spirosikmd/angular2-focus/issues/46\n   * @type {?}\n   */\n\n  AutofocusFixConfig.prototype.async;\n  /**\n   * In case `true`: treat an empty string, an empty array and an empty object as a falsy value.\n   * In case `false`(default): each of these values treats as truthy.\n   * @type {?}\n   */\n\n  AutofocusFixConfig.prototype.smartEmptyCheck;\n  /**\n   * In case `true`: trigger {\\@link ChangeDetectorRef.detectChanges}() after {\\@link HTMLElement.focus}().\n   *\n   * This is helpful in the case when the HTMLElement to which {\\@link AutofocusFixDirective} added\n   * wrapped by another directive/component that has some binding related to focus of the element.\n   * In this case without enabling .triggerChangeDetection option Angular throws ExpressionChangedAfterItHasBeenCheckedError.\n   *\n   * A striking example is the <mat-form-field> from the Angular Material that wraps <input> control.\n   * @type {?}\n   */\n\n  AutofocusFixConfig.prototype.triggerDetectChanges;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @param {?} value\n * @param {?=} smartEmptyCheck\n * @return {?}\n */\n\n\nfunction normalizeInputAsBoolean(value, smartEmptyCheck = false) {\n  /** @type {?} */\n  const isFalse = value === false || value === null || value === undefined || value === 0 || value === 'false' || value === 'null' || value === 'undefined' || value === '0' || typeof value === 'number' && isNaN(value) || value === 'NaN' || smartEmptyCheck && (value === '' // Notice: opposite default behavior!\n  || value instanceof Array && !value.length || value !== null && typeof value === 'object' && !Object.keys(value).length);\n  return !isFalse;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n// @todo: check configuration\n\n/**\n * ## Ways to turn off autofocus: any js-falsely value, except empty string\n *\n *     <!-- with data binding -->\n *     <input [autofocus]=\"\"> <!-- undefined value -->\n *     <input [autofocus]=\"undefined\">\n *     <input [autofocus]=\"false\">\n *     <input [autofocus]=\"null\">\n *     <input [autofocus]=\"0\">\n *     <input [autofocus]=\"NaN\">\n *\n *     <!-- without data binding -->\n *     <input autofocus=\"undefined\">\n *     <input autofocus=\"false\">\n *     <input autofocus=\"null\">\n *     <input autofocus=\"0\">\n *     <input autofocus=\"NaN\">\n *\n *     <input> <!-- disabled by default -->\n *\n *\n * ## Ways to enable autofocus: any js-true value and empty string\n *\n *     <!-- empty string will enable autofocus, this is default html behavior -->\n *     <input [autofocus]=\"''\">\n *     <input autofocus=\"\">\n *     <input autofocus>\n *\n *     <input [autofocus]=\"true\">\n *     <input autofocus=\"true\">\n *\n *     <input [autofocus]=\"'any other values'\">\n *\n * \\@dynamic\n * Notice: \\@dynamic used for correctly Document inject\n *         https://github.com/angular/angular/issues/20351\n */\n\n\nlet AutofocusFixDirective = /*#__PURE__*/(() => {\n  class AutofocusFixDirective {\n    /**\n     * @param {?} $er\n     * @param {?} $cdr\n     * @param {?} $document\n     * @param {?} $config\n     */\n    constructor($er, $cdr, $document, $config) {\n      this.$cdr = $cdr;\n      this.$document = $document;\n      this.$config = $config;\n      this.wasInitialized = false;\n      /**\n       * Notice: protected for unit testing\n       */\n\n      this.localConfig = {};\n      this.autofocusEnabled = false;\n      this.element = $er.nativeElement;\n    }\n    /**\n     * @param {?} changes\n     * @return {?}\n     */\n\n\n    ngOnChanges(changes) {\n      // Autofocus works only once. No need to do the initialization on each change detection cycle.\n      if (this.wasInitialized) {\n        return;\n      }\n\n      this.normalizeLocalConfigItem('async', changes.autofocusFixAsync);\n      this.normalizeLocalConfigItem('smartEmptyCheck', changes.autofocusFixSmartEmptyCheck);\n      this.normalizeLocalConfigItem('triggerDetectChanges', changes.autofocusFixTriggerDetectChanges);\n    }\n    /**\n     * @return {?}\n     */\n\n\n    ngOnInit() {\n      if (!this.element.focus) {\n        return console.warn('AutofocusFixDirective: There is no .focus() method on the element: %O', this.element);\n      }\n\n      this.config =\n      /** @type {?} */\n      {};\n      AutofocusFixConfig.keys.forEach(\n      /**\n      * @param {?} key\n      * @return {?}\n      */\n      key => {\n        /** @type {?} */\n        const local = this.localConfig[key];\n        this.config[key] = local !== undefined ? local : this.$config[key];\n      });\n      this.autofocusEnabled = normalizeInputAsBoolean(this.autofocus, this.config.smartEmptyCheck);\n    }\n    /**\n     * @return {?}\n     */\n\n\n    ngAfterContentInit() {\n      this.wasInitialized = true;\n\n      if (!this.element.focus) {\n        return;\n      }\n\n      this.checkFocus();\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n\n    checkFocus() {\n      this.config.async ? setTimeout(this.checkFocusInternal.bind(this)) : this.checkFocusInternal();\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n\n    checkFocusInternal() {\n      if (!this.autofocusEnabled || this.amIFocused) {\n        return;\n      }\n\n      this.element.focus();\n\n      if (this.config.triggerDetectChanges) {\n        this.$cdr.detectChanges();\n      }\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n\n    get amIFocused() {\n      return this.$document.activeElement === this.element;\n    }\n    /**\n     * @private\n     * @param {?} configKey\n     * @param {?=} change\n     * @return {?}\n     */\n\n\n    normalizeLocalConfigItem(configKey, change) {\n      if (change) {\n        this.localConfig[configKey] = normalizeInputAsBoolean(change.currentValue);\n      }\n    }\n\n  }\n\n  AutofocusFixDirective.ɵfac = function AutofocusFixDirective_Factory(t) {\n    return new (t || AutofocusFixDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(DOCUMENT), ɵngcc0.ɵɵdirectiveInject(AutofocusFixConfig));\n  };\n\n  AutofocusFixDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: AutofocusFixDirective,\n    selectors: [[\"\", \"autofocus\", \"\"]],\n    inputs: {\n      autofocus: \"autofocus\",\n      autofocusFixSmartEmptyCheck: \"autofocusFixSmartEmptyCheck\",\n      autofocusFixTriggerDetectChanges: \"autofocusFixTriggerDetectChanges\",\n      autofocusFixAsync: \"autofocusFixAsync\"\n    },\n    features: [ɵngcc0.ɵɵNgOnChangesFeature]\n  });\n  /** @nocollapse */\n\n  return AutofocusFixDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nif (false) {\n  /**\n   * Raw value. Always have default value: ''\n   * @type {?}\n   */\n  AutofocusFixDirective.prototype.autofocus;\n  /**\n   * @see {\\@link AutofocusFixConfig.smartEmptyCheck}\n   * @type {?}\n   */\n\n  AutofocusFixDirective.prototype.autofocusFixSmartEmptyCheck;\n  /**\n   * @see {\\@link AutofocusFixConfig.triggerDetectChanges}\n   * @type {?}\n   */\n\n  AutofocusFixDirective.prototype.autofocusFixTriggerDetectChanges;\n  /**\n   * @see {\\@link AutofocusFixConfig.async}\n   * @type {?}\n   */\n\n  AutofocusFixDirective.prototype.autofocusFixAsync;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  AutofocusFixDirective.prototype.wasInitialized;\n  /**\n   * Notice: protected for unit testing\n   * @type {?}\n   * @protected\n   */\n\n  AutofocusFixDirective.prototype.localConfig;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  AutofocusFixDirective.prototype.config;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  AutofocusFixDirective.prototype.autofocusEnabled;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  AutofocusFixDirective.prototype.element;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  AutofocusFixDirective.prototype.$cdr;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  AutofocusFixDirective.prototype.$document;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  AutofocusFixDirective.prototype.$config;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @return {?}\n */\n\n\nfunction noAutofocusFixConfigError() {\n  /** @type {?} */\n  const moduleName = 'AutofocusFixModule';\n  /** @type {?} */\n\n  const configName = 'AutofocusFixConfig';\n  throw new Error(`${moduleName}: Can't inject ${configName}.\n\n    Option 1: Use .forRoot() when you importing the module:\n              Do it in case you import ${moduleName} to the root module of your application.\n\n    @NgModule({\n      ...\n      imports: [\n        ...\n        ${moduleName}.forRoot(),     // <--- new code\n      ],\n      ...\n    })\n    export class AppModule {}\n\n\n    Option 2: Provide ${configName} manually providing ${configName}:\n              Do it in case you want to provide specific config to the one of your lazy loadable modules.\n\n    @NgModule({\n      ...\n      providers: [\n        ...\n        {                                               // <--- new code\n          provide: ${configName}                   // <---\n          useValue: new ${configName}({ ... }),    // <---\n        },                                              // <---\n      ],\n      ...\n    })\n    export class AppModule {}\n  `);\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n// Exists for AoT support\n\n/**\n * @param {?} options\n * @return {?}\n */\n\n\nfunction configFactory(options) {\n  return new AutofocusFixConfig(options);\n} // Exists for AoT support\n\n/** @type {?} */\n\n\nconst AutofocusFixOptionsInternalToken = new InjectionToken('AutofocusFixOptions');\nlet AutofocusFixModule = /*#__PURE__*/(() => {\n  class AutofocusFixModule {\n    /**\n     * @param {?} $config\n     */\n    constructor($config) {\n      if (!$config) {\n        noAutofocusFixConfigError();\n      }\n    }\n    /**\n     * @param {?=} options\n     * @return {?}\n     */\n\n\n    static forRoot(options = {}) {\n      return {\n        ngModule: AutofocusFixModule,\n        providers: [{\n          provide: AutofocusFixOptionsInternalToken,\n          useValue: options\n        }, {\n          provide: AutofocusFixConfig,\n          useFactory: configFactory,\n          deps: [AutofocusFixOptionsInternalToken]\n        }]\n      };\n    }\n\n  }\n\n  AutofocusFixModule.ɵfac = function AutofocusFixModule_Factory(t) {\n    return new (t || AutofocusFixModule)(ɵngcc0.ɵɵinject(AutofocusFixConfig, 8));\n  };\n\n  AutofocusFixModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: AutofocusFixModule\n  });\n  AutofocusFixModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({});\n  /** @nocollapse */\n\n  return AutofocusFixModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(AutofocusFixModule, {\n    declarations: [AutofocusFixDirective],\n    exports: [AutofocusFixDirective]\n  });\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nexport { AutofocusFixConfig, AutofocusFixModule, configFactory as ɵa, AutofocusFixDirective as ɵb }; //# sourceMappingURL=ngx-autofocus-fix.js.map","map":null,"metadata":{},"sourceType":"module"}